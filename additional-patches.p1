diff --git a/src/Makefile b/src/Makefile
index 53243dd..c0f1f37 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -32,7 +32,7 @@ HOST_CFLAGS += -Wall -W -Werror
 CFLAGS += -Os -ffreestanding -Wall -W -Werror -nostdinc -I. -fshort-wchar
 CFLAGS += -DVERSION="\"$(VERSION)\""
 
-CFLAGS_i386 += -m32 -march=i386 -malign-double
+CFLAGS_i386 += -m32 -march=i386 -malign-double -fno-pic
 CFLAGS_x86_64 += -m64 -mno-red-zone -fpie
 
 # Inhibit -fno-stack-protector
diff --git a/src/cmdline.c b/src/cmdline.c
index 204f8f9..2a50251 100644
--- a/src/cmdline.c
+++ b/src/cmdline.c
@@ -105,7 +105,7 @@ void process_cmdline ( char *cmdline ) {
 			cmdline_index = strtoul ( value, &endp, 0 );
 			if ( *endp )
 				die ( "Invalid index \"%s\"\n", value );
-		} else if ( strcmp ( key, "initrdfile" ) == 0 || strcmp ( key, "initrd" ) == 0) {
+		} else if ( strcmp ( key, "initrdfile" ) == 0 ) {
 			/* Ignore this keyword to allow for use with syslinux */
 		} else if ( key == cmdline ) {
 			/* Ignore unknown initial arguments, which may
diff --git a/src/efifile.c b/src/efifile.c
index a7d311d..93bfd64 100644
--- a/src/efifile.c
+++ b/src/efifile.c
@@ -117,61 +117,6 @@ static void efi_patch_bcd ( struct vdisk_file *vfile __unused, void *data,
 	}
 }
 
-static int
-isbootmgfw( const char *name)
-{
-	char bootarch[32];
-
-	if (strcasecmp(name, "bootmgfw.efi") == 0)
-		return 1;
-	snprintf ( bootarch, sizeof ( bootarch ), "%ls", efi_bootarch() );
-	return strcasecmp(name, bootarch) == 0;
-}
-
-static int
-addfile( const char *name, void *data, size_t len,  void ( * read ) ( struct vdisk_file *file,
-                                                       void *data,
-                                                       size_t offset,
-                                                       size_t len ) ) {
-	struct vdisk_file *vfile;
-
-	vfile = vdisk_add_file ( name, data, len, read );
-
-        /* Check for special-case files */
-	if ( isbootmgfw( name ) ) {
-		DBG ( "...found bootmgfw.efi file %s\n", name );
-		bootmgfw = vfile;
-	} else if ( strcasecmp ( name, "BCD" ) == 0 ) {
-		DBG ( "...found BCD\n" );
-		vdisk_patch_file ( vfile, efi_patch_bcd );
-	} else if ( strlen( name ) > 4 && strcasecmp ( ( name + ( strlen ( name ) - 4 ) ), ".wim" ) == 0 ) {
-		DBG ( "...found WIM file %s\n", name );
-		vdisk_patch_file ( vfile, patch_wim );
-		if ( ( ! bootmgfw ) &&
-		     ( bootmgfw = wim_add_file ( vfile, cmdline_index,
-                                                         bootmgfw_path,
-                                                         efi_bootarch() ) ) ) {
-			DBG ( "...extracted %ls\n", bootmgfw_path );
-		}
-	}
-	return 0;
-}
-
-/**
- * File handler
- *
- * @v name              File name
- * @v data              File data
- * @v len               Length
- * @ret rc              Return status code
- */
-int
-efi_add_file ( const char *name, void *data, size_t len)
-{
-	return addfile(name, data, len, read_mem_file);
-}
-
-
 /**
  * Extract files from EFI file system
  *
@@ -188,6 +133,7 @@ void efi_extract ( EFI_HANDLE handle ) {
 		CHAR16 name[ VDISK_NAME_LEN + 1 /* WNUL */ ];
 	} __attribute__ (( packed )) info;
 	char name[ VDISK_NAME_LEN + 1 /* NUL */ ];
+	struct vdisk_file *vfile;
 	EFI_FILE_PROTOCOL *root;
 	EFI_FILE_PROTOCOL *file;
 	UINTN size;
@@ -240,7 +186,28 @@ void efi_extract ( EFI_HANDLE handle ) {
 
 		/* Add file */
 		snprintf ( name, sizeof ( name ), "%ls", wname );
-		addfile(name, file, info.file.FileSize, efi_read_file);
+		vfile = vdisk_add_file ( name, file, info.file.FileSize,
+					 efi_read_file );
+
+		/* Check for special-case files */
+		if ( ( wcscasecmp ( wname, efi_bootarch() ) == 0 ) ||
+		     ( wcscasecmp ( wname, L"bootmgfw.efi" ) == 0 ) ) {
+			DBG ( "...found bootmgfw.efi file %ls\n", wname );
+			bootmgfw = vfile;
+		} else if ( wcscasecmp ( wname, L"BCD" ) == 0 ) {
+			DBG ( "...found BCD\n" );
+			vdisk_patch_file ( vfile, efi_patch_bcd );
+		} else if ( wcscasecmp ( ( wname + ( wcslen ( wname ) - 4 ) ),
+					 L".wim" ) == 0 ) {
+			DBG ( "...found WIM file %ls\n", wname );
+			vdisk_patch_file ( vfile, patch_wim );
+			if ( ( ! bootmgfw ) &&
+			     ( bootmgfw = wim_add_file ( vfile, cmdline_index,
+							 bootmgfw_path,
+							 efi_bootarch() ) ) ) {
+				DBG ( "...extracted %ls\n", bootmgfw_path );
+			}
+		}
 	}
 
 	/* Check that we have a boot file */
diff --git a/src/efimain.c b/src/efimain.c
index 7315c81..3207dec 100644
--- a/src/efimain.c
+++ b/src/efimain.c
@@ -32,15 +32,6 @@
 #include "efiblock.h"
 #include "efiboot.h"
 
-#include "string.h"
-#include "cpio.h"
-
-/** initrd */
-void *initrd;
-
-/** Length of initrd */
-size_t initrd_len;
-
 /**
  * Process command line
  *
@@ -97,13 +88,8 @@ EFI_STATUS EFIAPI efi_main ( EFI_HANDLE image_handle,
 	/* Process command line */
 	efi_cmdline ( loaded.image );
 
-	if(initrd_len){
-		/* Extract files from initrd (syslinux) */
-		cpio_extract ( initrd, initrd_len, efi_add_file );
-	} else {
-		/* Extract files from file system */
-		efi_extract ( loaded.image->DeviceHandle );
-	}
+	/* Extract files from file system */
+	efi_extract ( loaded.image->DeviceHandle );
 
 	/* Install virtual disk */
 	efi_install ( &vdisk, &vpartition );
@@ -113,24 +99,3 @@ EFI_STATUS EFIAPI efi_main ( EFI_HANDLE image_handle,
 
 	return 0;
 }
-
-void
-efi_linuxentry(EFI_HANDLE image_handle, EFI_SYSTEM_TABLE *systab, uint32_t *bp)
-{
-	efi_image_handle = image_handle;
-	efi_systab = systab;
-
-#if __x86_64__
-	extern char _bss[];
-	extern char _ebss[];
-	memset(_bss, 0, _ebss-_bss);
-#endif
-
-	if(bp){
-		initrd = (void*)(intptr_t)bp[0x218/4];
-		initrd_len = (size_t)bp[0x21c/4];
-	}
-
-	efi_main(image_handle, systab);
-}
-
diff --git a/src/main.c b/src/main.c
index bc5021f..0069998 100644
--- a/src/main.c
+++ b/src/main.c
@@ -196,6 +196,20 @@ static int is_empty_pgh ( const void *pgh ) {
 	return ( ( dwords[0] | dwords[1] | dwords[2] | dwords[3] ) == 0 );
 }
 
+/**
+ * Read from file
+ *
+ * @v file		Virtual file
+ * @v data		Data buffer
+ * @v offset		Offset
+ * @v len		Length
+ */
+static void read_file ( struct vdisk_file *file, void *data, size_t offset,
+			size_t len ) {
+
+	memcpy ( data, ( file->opaque + offset ), len );
+}
+
 /**
  * Add embedded bootmgr.exe extracted from bootmgr
  *
@@ -291,7 +305,8 @@ static struct vdisk_file * add_bootmgr ( const void *data, size_t len ) {
 		decompress ( compressed, compressed_len, initrd );
 
 		/* Add decompressed image */
-		return vdisk_add_file ( "bootmgr.exe", initrd, decompressed_len, read_mem_file );
+		return vdisk_add_file ( "bootmgr.exe", initrd,
+					decompressed_len, read_file );
 	}
 
 	DBG ( "...no embedded bootmgr.exe found\n" );
@@ -310,7 +325,7 @@ static int add_file ( const char *name, void *data, size_t len ) {
 	struct vdisk_file *file;
 
 	/* Store file */
-	file = vdisk_add_file ( name, data, len, read_mem_file );
+	file = vdisk_add_file ( name, data, len, read_file );
 
 	/* Check for special-case files */
 	if ( strcasecmp ( name, "bootmgr.exe" ) == 0 ) {
@@ -363,7 +378,7 @@ int main ( void ) {
 	/* Read bootmgr.exe into memory */
 	if ( ! bootmgr )
 		die ( "FATAL: no bootmgr.exe\n" );
-	if ( bootmgr->read == read_mem_file ) {
+	if ( bootmgr->read == read_file ) {
 		raw_pe = bootmgr->opaque;
 	} else {
 		padded_len = ( ( bootmgr->len + PAGE_SIZE - 1 ) &
diff --git a/src/prefix.S b/src/prefix.S
index 068cb6c..d19cc29 100644
--- a/src/prefix.S
+++ b/src/prefix.S
@@ -33,12 +33,8 @@
 #define i386(symbol) symbol
 #endif
 
-/*
- * Standard number of setup sectors was 5,
- * but we need to round it to 4k to page
- * align _payload.
- */
-#define SETUP_SECTS ((0x1000/SECTOR_SIZE)-1)
+/** Standard number of setup sectors */
+#define SETUP_SECTS 4
 
 /** Sector size */
 #define SECTOR_SIZE 512
@@ -223,7 +219,7 @@ header:
 
 	.org	0x206
 version:
-	.word  0x20b	/* Version 2.11 */
+	.word	0x203	/* Version 2.03 */
 
 	.org	0x20e
 kernel_version:
@@ -233,10 +229,6 @@ kernel_version:
 loadflags:
 	.byte	LOADED_HIGH
 
-	.org	0x214
-code32_start:
-	.long	0
-
 	.org	0x218
 ramdisk_image:
 	.long	0	/* Filled in by boot loader */
@@ -253,37 +245,6 @@ cmd_line_ptr:
 ramdisk_max:
 	.long	0x7fffffff
 
-	.org	0x236
-xloadflags:
-	.word	(1<<3)
-
-	.org	0x238
-cmdline_size:
-	.long	256
-
-	.org	0x23c
-hardware_subarch:
-	.long	0
-
-	.org	0x258
-prefaddr:
-	.long	_payload
-	.long	0
-
-	.org	0x260
-init_size:
-	.long	0x10000
-
-	.org	0x264
-handover_offset:
-	/*
-	 * really would like to write efihandover-_payload here,
-	 * but we cant as efihandover its part of the payload
-	 * section.  0x4000 is the page rounded size of this
-	 * prefix setion (4k) + text16/bss16 section (12k).
-	 */
-	.long ( efihandover-BASE_ADDRESS-0x4000 )
-
 version_string:
 	.asciz	VERSION
 
diff --git a/src/startup.S b/src/startup.S
index b07e234..d86909b 100644
--- a/src/startup.S
+++ b/src/startup.S
@@ -57,15 +57,6 @@ startup:
 	jmp	reboot
 	.size	startup, . - startup
 
-	.section ".text", "ax", @progbits
-	.globl	efihandover
-	.globl	efihandover64
-efihandover:
-        .org    .+512, 0x90
-efihandover64:
-	jmp	efi_linuxentry
-	.size	startup, . - startup
-
 	/* Reboot system */
 	.section ".text", "ax", @progbits
 	.globl	reboot
diff --git a/src/vdisk.c b/src/vdisk.c
index ee6eed4..7885a5b 100644
--- a/src/vdisk.c
+++ b/src/vdisk.c
@@ -613,19 +613,6 @@ void vdisk_read ( uint64_t lba, unsigned int count, void *data ) {
 	DBG2 ( "\n" );
 }
 
-/**
- * Read from file
- *
- * @v file              Virtual file
- * @v data              Data buffer
- * @v offset            Offset
- * @v len               Length
- */
-void read_mem_file ( struct vdisk_file *file, void *data, size_t offset, size_t len ) {
-        memcpy ( data, ( file->opaque + offset ), len );
-}
-
-
 /**
  * Add file to virtual disk
  *
diff --git a/src/vdisk.h b/src/vdisk.h
index 4728fd0..7cae51c 100644
--- a/src/vdisk.h
+++ b/src/vdisk.h
@@ -610,15 +610,11 @@ struct vdisk_file {
 
 extern struct vdisk_file vdisk_files[VDISK_MAX_FILES];
 
-
 extern void vdisk_read ( uint64_t lba, unsigned int count, void *data );
 extern struct vdisk_file *
 vdisk_add_file ( const char *name, void *opaque, size_t len,
 		 void ( * read ) ( struct vdisk_file *file, void *data,
 				   size_t offset, size_t len ) );
-
-extern void read_mem_file ( struct vdisk_file *file, void *data, size_t offset, size_t len );
-
 extern void
 vdisk_patch_file ( struct vdisk_file *file,
 		   void ( * patch ) ( struct vdisk_file *file, void *data,
